# To use this, have a file called "test_input.py" in the same directory and run this program
(lambda _Y: (lambda ast: (lambda sys: (lambda construct_lambda: (lambda provide_y: (lambda wrap_globals: (lambda Flatliner: ([sys.setrecursionlimit(20000), (lambda test: [test.set_ast('test_input.py'), (lambda result: print(result))(test.unparse())][-1])(Flatliner())][-1] if __name__ == '__main__' else None))(type("Flatliner", (), {'__init__': lambda self: [[[[[None for self.node_handlers in [{ast.Assign: self.handle_assign, ast.AugAssign: self.handle_augassign, ast.Constant: self.handle_constant, ast.Expr: self.handle_expr, ast.keyword: self.handle_keyword, ast.Call: self.handle_call, ast.Name: self.handle_name, ast.Raise: self.handle_raise, ast.Assert: self.handle_assert, ast.Pass: self.handle_pass, ast.Break: self.handle_loop_flow, ast.Continue: self.handle_loop_flow, ast.While: self.handle_while, ast.For: self.handle_for, ast.List: self.handle_list, ast.Tuple: self.handle_tuple, ast.Set: self.handle_set, ast.Dict: self.handle_dict, ast.Subscript: self.handle_subscript, ast.Slice: self.handle_slice, ast.Attribute: self.handle_attribute, ast.BinOp: self.handle_binop, ast.If: self.handle_if, ast.IfExp: self.handle_if, list: self.unparse_list, ast.Compare: self.handle_compare, ast.BoolOp: self.handle_boolop, ast.UnaryOp: self.handle_unaryop, ast.FunctionDef: self.handle_functiondef, ast.ClassDef: self.handle_classdef, ast.Return: self.handle_return, ast.Import: self.handle_import, ast.ImportFrom: self.handle_importfrom}]][0] for self.loop_no in [1]][0] for self.needs_y in [False]][0] for self.ast in [None]][0], None][-1], 'set_ast': lambda self, infile: (lambda file: [file.close() for self.ast in [ast.parse(file.read())]][0])(open(infile, 'r')), 'apply_handler': lambda self, node, cont=None: self.node_handlers.get(type(node), self.handle_error)(node, cont), 'handle_constant': lambda self, node, cont: repr(node.value), 'handle_name': lambda self, node, cont: node.id, 'handle_pass': lambda self, node, cont: cont, 'handle_loop_flow': lambda self, node, cont: node.contents, 'handle_raise': lambda self, node, cont: f'(_ for _ in []).throw({self.apply_handler(node.exc)})', 'handle_assert': lambda self, node, cont: (lambda message: (lambda error: f'({cont} if {self.apply_handler(node.test)} else {self.apply_handler(error)})')(ast.parse(f'raise AssertionError{message}').body[0]))(('' if node.msg is None else f'({self.apply_handler(node.msg)})')), '_next_item': lambda self: f'next(_items{self.loop_no}, _term{self.loop_no})', 'handle_while': lambda self, node, cont: [(lambda assigned_in_loop: (lambda assigned_in_loop: (lambda assigned_in_loop: (lambda assigned_in_loop: (lambda args: (lambda loop_test: (lambda loop_id: (lambda loop_call: (lambda _term1, _items1: (lambda _targ1: (lambda _targ1, n: (lambda _loop1: _loop1(_targ1, n))(_Y(lambda _loop1: (lambda _targ1, n: ((lambda n: ([(([(lambda _targ1: _loop1(_targ1, n))(next(_items1, _term1)) for n.contents in [construct_lambda({node.target: self._next_item()}, loop_call)]][0] if hasattr(node, 'target') else [(lambda _targ1: _loop1(_targ1, n))(next(_items1, _term1)) for n.contents in [loop_call]][0]) if isinstance(n, ast.Continue) else (lambda _targ1: _loop1(_targ1, n))(next(_items1, _term1))) for n.contents in [cont]][0] if isinstance(n, ast.Break) else (([(lambda _targ1: _loop1(_targ1, n))(next(_items1, _term1)) for n.contents in [construct_lambda({node.target: self._next_item()}, loop_call)]][0] if hasattr(node, 'target') else [(lambda _targ1: _loop1(_targ1, n))(next(_items1, _term1)) for n.contents in [loop_call]][0]) if isinstance(n, ast.Continue) else (lambda _targ1: _loop1(_targ1, n))(next(_items1, _term1)))))(_targ1)) if _targ1 is not _term1 else [(lambda loop_body: (lambda loop_repr: construct_lambda({v: f'{v} if "{v}" in dir() else None' for v in assigned_in_loop}, loop_repr))(construct_lambda({loop_id: f'_Y(lambda {loop_id}: (lambda {args}: ({loop_body}) if {loop_test} else {cont}))'}, loop_call)))(self.apply_handler(node.body, loop_call)) for self.loop_no in [(self.loop_no + 1)]][0]))))(_targ1 if "_targ1" in dir() else None, n if "n" in dir() else None))(next(_items1, _term1)))([], iter(ast.walk(node))))(f'{loop_id}({args})'))(f'_loop{self.loop_no}'))(self.apply_handler(node.test)))(', '.join(assigned_in_loop)))(sorted(assigned_in_loop)))((assigned_in_loop | {self.apply_handler(child) for n in ast.walk(node) if isinstance(n, ast.Assign) and isinstance(n.targets[0], ast.Tuple) for child in n.targets[0].elts if not any((isinstance(n2, (ast.Attribute, ast.Subscript)) for n2 in ast.walk(child)))})))((assigned_in_loop | {self.apply_handler(n.target) for n in ast.walk(node) if isinstance(n, ast.AugAssign) and (not isinstance(n.target, (ast.Attribute, ast.Subscript)))})))({self.apply_handler(n.targets[0]) for n in ast.walk(node) if isinstance(n, ast.Assign) and (not isinstance(n.targets[0], (ast.Attribute, ast.Subscript, ast.Tuple))) and (len(n.targets) == 1)}) for self.needs_y in [True]][0], 'handle_for': lambda self, node, cont: (lambda target_id: (lambda iter_id: (lambda term_id: (lambda pre: (lambda post: (lambda body_list: (lambda while_test: (lambda while_equivalent: [construct_lambda({term_id: '[]', iter_id: f'iter({self.apply_handler(node.iter)})'}, construct_lambda({target_id: self._next_item()}, self.apply_handler(while_equivalent, cont))) for while_equivalent.target in [target_id]][0])(ast.While(while_test, body_list)))(ast.parse(f'{target_id} is not {term_id}').body[0]))(((pre + node.body) + post)))(ast.parse(f'{target_id} = {self._next_item()}').body))(ast.parse(f'{self.apply_handler(node.target)} = {target_id}').body))(f'_term{self.loop_no}'))(f'_items{self.loop_no}'))(f'_targ{self.loop_no}'), '_handle_container': lambda self, node: ', '.join((self.apply_handler(child) for child in node.elts)), 'handle_list': lambda self, node, cont: f'[{self._handle_container(node)}]', 'handle_tuple': lambda self, node, cont: f"({self._handle_container(node)}{',' * (len(node.elts) == 1)})", 'handle_set': lambda self, node, cont: (('{' + self._handle_container(node)) + '}'), 'handle_dict': lambda self, node, cont: (('{' + ', '.join((f'{k}: {v}' for (k, v) in zip(map(self.apply_handler, node.keys), map(self.apply_handler, node.values))))) + '}'), 'handle_slice': lambda self, node, cont: (lambda parts: ':'.join(parts))([self.apply_handler(n) if n is not None else '' for n in [node.lower, node.upper, node.step]]), 'handle_subscript': lambda self, node, cont: f'{self.apply_handler(node.value)}[{self.apply_handler(node.slice)}]', 'handle_attribute': lambda self, node, cont: f'{self.apply_handler(node.value)}.{node.attr}', 'handle_assign': lambda self, node, cont: ((lambda targets: f"[{cont} for {', '.join(targets)} in [[{self.apply_handler(node.value)}] * {len(targets)}]][0]")([self.apply_handler(t) for t in node.targets]) if len(node.targets) > 1 else (lambda target: (f'[{cont} for {self.apply_handler(target)} in [{self.apply_handler(node.value)}]][0]' if isinstance(target, (ast.Attribute, ast.Subscript, ast.Tuple)) else construct_lambda({self.apply_handler(target): self.apply_handler(node.value)}, cont)))(node.targets[0])), 'handle_augassign': lambda self, node, cont: (lambda assign_equivalent: self.apply_handler(assign_equivalent, cont))(ast.Assign([node.target], ast.BinOp(node.target, node.op, node.value))), 'handle_expr': lambda self, node, cont: self.apply_handler(node.value, cont), 'handle_keyword': lambda self, node, cont: f'{node.arg}={self.apply_handler(node.value)}', 'handle_call': lambda self, node, cont: (lambda args: (lambda call: (call if not cont else f'[{call}, {cont}][-1]'))(f'{self.apply_handler(node.func)}({args})'))(', '.join((self.apply_handler(child) for child in node.args + node.keywords))), 'handle_binop': lambda self, node, cont: (lambda op_map: f'({self.apply_handler(node.left)} {op_map[type(node.op)]} {self.apply_handler(node.right)})')({ast.Add: '+', ast.Sub: '-', ast.Mult: '*', ast.Div: '/', ast.FloorDiv: '//', ast.Mod: '%', ast.Pow: '**', ast.LShift: '<<', ast.RShift: '>>', ast.BitOr: '|', ast.BitXor: '^', ast.BitAnd: '&'}), 'handle_boolop': lambda self, node, cont: (lambda op_map: f' {op_map[type(node.op)]} '.join((self.apply_handler(child) for child in node.values)))({ast.And: 'and', ast.Or: 'or'}), 'handle_unaryop': lambda self, node, cont: (lambda op_map: (f'{op_map[type(node.op)]}{self.apply_handler(node.operand)}' if isinstance(node.operand, (ast.Name, ast.Constant)) else f'{op_map[type(node.op)]}({self.apply_handler(node.operand)})'))({ast.UAdd: '+', ast.USub: '-', ast.Not: 'not ', ast.Invert: '~'}), 'handle_if': lambda self, node, cont: f'({self.apply_handler(node.body, cont)} if {self.apply_handler(node.test)} else {self.apply_handler(node.orelse, cont)})', 'handle_compare': lambda self, node, cont: (lambda op_map: (lambda comparisons: f'{self.apply_handler(node.left)}{comparisons}')(''.join((f' {op_map[type(op)]} ' + self.apply_handler(val) for (op, val) in zip(node.ops, node.comparators)))))({ast.Gt: '>', ast.Lt: '<', ast.GtE: '>=', ast.LtE: '<=', ast.Eq: '==', ast.NotEq: '!=', ast.In: 'in', ast.Is: 'is', ast.IsNot: 'is not', ast.NotIn: 'not in'}), 'handle_methoddef': lambda self, node, cont: (lambda all_args: (lambda defaults: (lambda padding: (lambda args: (lambda _term2, _items2: (lambda _targ2: (lambda _targ2, n: (lambda _loop2: _loop2(_targ2, n))(_Y(lambda _loop2: (lambda _targ2, n: ((lambda n: ([(lambda _targ2: _loop2(_targ2, n))(next(_items2, _term2)) for n.func.id in ['self.__class__']][0] if cont and isinstance(n, ast.Call) and self.apply_handler(n.func) == cont.split('.')[0] else (lambda _targ2: _loop2(_targ2, n))(next(_items2, _term2))))(_targ2)) if _targ2 is not _term2 else (f"lambda{(' ' if args else '')}{args}: [{self.apply_handler(node.body)}, None][-1]" if cont.endswith('__init__') else ([f'_Y(lambda {node.name}: (lambda {args}: {self.apply_handler(node.body)}))' for self.needs_y in [True]][0] if any((isinstance(n, ast.Call) and self.apply_handler(n.func) == node.name for n in ast.walk(node))) else f"lambda{(' ' if args else '')}{args}: {self.apply_handler(node.body)}"))))))(_targ2 if "_targ2" in dir() else None, n if "n" in dir() else None))(next(_items2, _term2)))([], iter(ast.walk(node))))(', '.join((arg + val for (arg, val) in zip(all_args, padding + defaults)))))(([''] * (len(all_args) - len(defaults)))))([f'={self.apply_handler(val)}' for val in node.args.defaults]))([arg.arg for arg in node.args.args]), 'handle_functiondef': lambda self, node, cont: (lambda curr: (lambda _term3, _items3: (lambda _targ3: (lambda _targ3, curr, n: (lambda _loop3: _loop3(_targ3, curr, n))(_Y(lambda _loop3: (lambda _targ3, curr, n: ((lambda n: (lambda curr: (lambda _targ3: _loop3(_targ3, curr, n))(next(_items3, _term3)))(f'{self.apply_handler(n)}({curr})'))(_targ3)) if _targ3 is not _term3 else construct_lambda({node.name: curr}, cont)))))(_targ3 if "_targ3" in dir() else None, curr if "curr" in dir() else None, n if "n" in dir() else None))(next(_items3, _term3)))([], iter(node.decorator_list[::-1])))(self.handle_methoddef(node, '')), 'handle_classdef': lambda self, node, cont: (lambda attr_dict: (lambda _term4, _items4: (lambda _targ4: (lambda _targ4, n: (lambda _loop4: _loop4(_targ4, n))(_Y(lambda _loop4: (lambda _targ4, n: ((lambda n: ([(lambda _targ4: _loop4(_targ4, n))(next(_items4, _term4)) for attr_dict[n.name] in [self.handle_methoddef(n, f'{node.name}.{n.name}')]][0] if isinstance(n, ast.FunctionDef) else (lambda _targ4: _loop4(_targ4, n))(next(_items4, _term4))))(_targ4)) if _targ4 is not _term4 else (lambda bases: (lambda attr_repr: construct_lambda({node.name: f'type("{node.name}", ({bases}), {attr_repr})'}, cont))((('{' + ', '.join((f'{repr(k)}: {v}' for (k, v) in attr_dict.items()))) + '}')))(''.join((self.apply_handler(n) + ', ' for n in node.bases)))))))(_targ4 if "_targ4" in dir() else None, n if "n" in dir() else None))(next(_items4, _term4)))([], iter(node.body)))({}), 'handle_return': lambda self, node, cont: ('None' if node.value is None else self.apply_handler(node.value)), 'handle_import': lambda self, node, cont: (lambda imports: construct_lambda({name.split('.')[0]: f"__import__('{mod}')" for (name, mod) in imports}, cont))([(a.asname if a.asname else a.name, a.name) for a in node.names]), 'handle_importfrom': lambda self, node, cont: (lambda imports: construct_lambda({'_mod': f"__import__('{node.module}', {{}}, {{}}, {[i[1] for i in imports]})"}, construct_lambda({name: f'_mod.{submodule}' for (name, submodule) in imports}, cont)))([(a.asname if a.asname else a.name, a.name) for a in node.names]), 'handle_error': lambda self, node, cont: ast.unparse(node), 'unparse_list': lambda self, body, cont=None: (lambda temp: (lambda _term5, _items5: (lambda _targ5: (lambda _targ5, node, temp: (lambda _loop5: _loop5(_targ5, node, temp))(_Y(lambda _loop5: (lambda _targ5, node, temp: ((lambda node: ((lambda temp: (lambda _targ5: _loop5(_targ5, node, temp))(next(_items5, _term5)))(self.apply_handler(node, temp)) if not (isinstance(node, ast.Expr)) or isinstance(node.value, ast.Call) else (lambda _targ5: _loop5(_targ5, node, temp))(next(_items5, _term5))))(_targ5)) if _targ5 is not _term5 else str(temp)))))(_targ5 if "_targ5" in dir() else None, node if "node" in dir() else None, temp if "temp" in dir() else None))(next(_items5, _term5)))([], iter(body[::-1])))(cont), 'unparse': lambda self: [[(lambda curr: ((lambda body: (provide_y(body) if self.needs_y else body))(self.apply_handler(curr.body)) if hasattr(curr, 'body') and isinstance(curr.body, list) else 'Unparse unsuccessful.'))(self.ast) for self.loop_no in [1]][0] for self.needs_y in [False]][0]})))(lambda body: construct_lambda({'__g': 'globals()'}, body)))(lambda body: construct_lambda({'_Y': '(lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args))))'}, body)))(lambda vals, body='{}': f"(lambda {', '.join(vals.keys())}: {body})({', '.join(vals.values())})"))(__import__('sys')))(__import__('ast')))((lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))))
